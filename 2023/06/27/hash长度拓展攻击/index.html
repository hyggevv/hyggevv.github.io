<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="在密码学和计算机安全中,长度扩展攻击是指针对某些允许包含额外信息加密的加密散列函数的攻击手段。又由于hash的生成机制原因，使得我们可以人为的在原先明文数据的基础上添加新的拓展字符，使得原本的加密链变长，进而控制加密链的最后一节，使得我们得以控制最终结果。">
<meta property="og:type" content="article">
<meta property="og:title" content="hash length extension attacks(hash长度拓展攻击)">
<meta property="og:url" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/index.html">
<meta property="og:site_name" content="hey&#39;s blog">
<meta property="og:description" content="在密码学和计算机安全中,长度扩展攻击是指针对某些允许包含额外信息加密的加密散列函数的攻击手段。又由于hash的生成机制原因，使得我们可以人为的在原先明文数据的基础上添加新的拓展字符，使得原本的加密链变长，进而控制加密链的最后一节，使得我们得以控制最终结果。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/3.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/4.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/1.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/5.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/7.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/6.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/8.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/9.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/10.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/16.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/11.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/12.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/14.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/12.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/16.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/17.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/15.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/18.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/19.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/20.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/21.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/22.png">
<meta property="og:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/23.png">
<meta property="article:published_time" content="2023-06-27T04:54:30.000Z">
<meta property="article:modified_time" content="2023-06-27T15:36:15.400Z">
<meta property="article:author" content="hey">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2.png"><title>hash length extension attacks(hash长度拓展攻击) | hey's blog</title><link ref="canonical" href="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categories</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Tags</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">About</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/read/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">menu.read</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">hey's blog</div><div class="header-banner-info__subtitle">天气转晴太阳崭新我在前进</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">hash length extension attacks(hash长度拓展攻击)</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-06-27</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-06-27</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visited</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h2 id="hash算法和hash长度拓展攻击">
          <a href="#hash算法和hash长度拓展攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#hash算法和hash长度拓展攻击" class="headerlink" title="hash算法和hash长度拓展攻击"></a>hash算法和hash长度拓展攻击</h2>
      <p>hash算法:hash算法又叫做散列算法。是一种把任意长度的字符串加密为固定长度的字符串的加密算法，此时该算法生成的密文就是散列值。简言之：hash算法就是一种通过单向函数加密明文生成信息摘要的算法。<br>由于hash的生成机制使得我们可以人为的在原先的明文基础上添加新的拓展字符，使得原本的加密链变长，进一步控制到加密链的最后一节；达到我们得以控制最终的结果。<br>推荐文章：<br><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks">https://www.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="MD5算法">
          <a href="#MD5算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h1>
      
        <h2 id="MD5加密">
          <a href="#MD5加密" class="heading-link"><i class="fas fa-link"></i></a><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h2>
      <p>MD5算法是典型的一种信息摘要算法，它是由md2、md3、md4演变来的。无论是哪种md算法都是将一个任意长度的字符串加密成为一串固定的密文。在这个加密过程中会将明文字符串转换为一个128位的信息摘要；接着把这个信息摘要转换为一个十六进制的字符串就会得到32位的字符串，此时的32位的字符串也就是我们平时见到的MD5密文。<br>ps:因为在MD5加密过程中经过了压缩、加密、hash算法，所以此时MD5加密的内容是不可逆的</p>

        <h2 id="MD5算法-1">
          <a href="#MD5算法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#MD5算法-1" class="headerlink" title="MD5算法"></a>MD5算法</h2>
      
        <h3 id="初识MD5算法">
          <a href="#初识MD5算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#初识MD5算法" class="headerlink" title="初识MD5算法"></a>初识MD5算法</h3>
      <p>1.把消息分成n个分组<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/2.png"><br>2.对最后一个分组进行填充(很重要的一步)<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/3.png"><br>3.将每一个分组划分成16个子分组，然后对每一个输入量进行运算；运算结果作为下一个分组的输入量<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/4.png"><br>4.输出最终结果<br>整个算法的流程图如下<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/1.png"></p>

        <h3 id="深入MD5算法">
          <a href="#深入MD5算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#深入MD5算法" class="headerlink" title="深入MD5算法"></a>深入MD5算法</h3>
      <p>此时在计算时会初始化四个寄存器A、B、C、D，此时的他们分别都会有他们的初始值<br>初始值如下：<br>A: 01 23 45 67<br>B: 89 ab cd ef<br>C: fe dc ba 98<br>D: 76 54 32 10<br>此时md5算法是以512bit为一个块进行迭代计算；当在第一个块算完之后，四个寄存器的值都会被更新，如果还存在下一个块则会在现在的者四个寄存器上继续迭代计算；等到全部的块计算完毕之后，四个寄存器的十六进制连起来就是最终的MD5值。<br>然而我们不可能确保最后一个数据的长度是512bit；所以此时我们需要进行一个填充(当前数据长度不满足对512求余为448)<br>ps:为什么要求当前长度对512bit求余为448bit?<br>因为我们要留出64bit来存放原消息(当原消息长度超过64bit时取低64bit)<br>填充方法：<br>1.首先补一个1(Bin)<br>2.接着在后面补0(Bin)直到满足比特长度对512求余为448时即可<br>3.接着补64bit的长度；这个长度是在补1和0以前的长度；此时如果长度超过了64bit则取低64bit<br>此时补完的一块可能长这样</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raw_data + &#x27;\x80&#x27; + &#x27;\x00&#x27;*n + &#x27;\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br></pre></td></tr></table></div></figure>
<p>此时的raw_data的部分就是原始的数据；第二个部分’\80’是一开始补的一个二进制位1，接着补若干个\x00，直到整个长度达到56Byte(448bit),然后最后的8Byt<br>e就是raw_data的长度，此时如果raw_data的长度超过了2^64bit则取低的64bit<br>tips:在MD5算法中的补位这一个部分就是实现长度拓展攻击的关键</p>

        <h2 id="MD5加密demo测试">
          <a href="#MD5加密demo测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#MD5加密demo测试" class="headerlink" title="MD5加密demo测试"></a>MD5加密demo测试</h2>
      <p>此时我们要对0123456789abcdef进行加密；第一步转成二进制此时我们可以得到128位的二进制；然后此时在转为十六进制<br>此时我们先在010中写下我们要加密字符串的十六进制<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/5.png"><br>此时进行填充：<br>1.先在二进制下的第一位补一个1又因为八位的二进制可以转十六进制；所以10000000(Bin) &#x3D; 80(Hex);所以此时我们补一个80上去<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/7.png"><br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/6.png"><br>2.接下来依次补0；补到448bit也就是56Byte<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/8.png"><br>3.补剩下的64bit(8Byte);此时原始明文为0123456789abcdef一共16Byte，有128bit；此时将128转为十六进制写入；然后后面的7Byte补0<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/9.png"><br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/10.png"><br>然后接下来就会使用这64Byte的数据进行计算。计算信息的摘要需要用补位结果的数据进行运算，也就是补位后的512bit的消息，在计算时候有一个初始的向量，这里初始的向量是一个固定的值。<br>由于在计算机存储中采用的是小端存储方式，所以上面的初始化向量在程序中的初始化代码为后面的0x部分。<br>然后将刚才的512bit消息和初始化向量进行第一轮的运算，之后初始化向量会被新的值覆盖，最后一轮的向量经过高低位互换后就是计算出的MD5值。<br>高低位互换:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">假如最后一轮的运算后的向量值为：</span><br><span class="line">    A=0xabcdef12</span><br><span class="line">    B=0xabcdef12</span><br><span class="line">    C=0xabcdef12</span><br><span class="line">    D=0xabcdef12</span><br><span class="line">那么进行高低位互换之后得到的数值为：</span><br><span class="line">12 ef cd ab</span><br><span class="line">12 ef cd ab</span><br><span class="line">12 ef cd ab</span><br><span class="line">12 ef cd ab</span><br><span class="line">进行拼接得到最后加密结果</span><br><span class="line">12efcdab12efcdab12efcdab12efcdab</span><br></pre></td></tr></table></div></figure>


        <h2 id="从算法方面看MD5加密">
          <a href="#从算法方面看MD5加密" class="heading-link"><i class="fas fa-link"></i></a><a href="#从算法方面看MD5加密" class="headerlink" title="从算法方面看MD5加密"></a>从算法方面看MD5加密</h2>
      <p>计算test的md5值:<br>补位完后</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000</span><br></pre></td></tr></table></div></figure>
<p><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/16.png"><br>将补位后的数据进行一次复杂计算得出</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=0xcd6b8f09</span><br><span class="line">B=0x73d32146</span><br><span class="line">C=0x834edeca</span><br><span class="line">D=0xf6b42726</span><br></pre></td></tr></table></div></figure>
<p>数据小于512位，所以将ABCD通过小端规则转换就是MD5值：098f6bcd4621d373cade4e832627b4f6<br>ps:如果我输入的数据不是test而是一串很长的字符，换算出来大于512小于1024，就需要计算两次，第一次先计算前512位的ABCD的值，算出来后再用这个ABCD去计算后面512位的的ABCD的值，最后算出来的ABCD经过拼接就是这串字符的MD5了</p>

        <h1 id="hash长度拓展攻击">
          <a href="#hash长度拓展攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#hash长度拓展攻击" class="headerlink" title="hash长度拓展攻击"></a>hash长度拓展攻击</h1>
      
        <h2 id="hash扩展长度攻击demo">
          <a href="#hash扩展长度攻击demo" class="heading-link"><i class="fas fa-link"></i></a><a href="#hash扩展长度攻击demo" class="headerlink" title="hash扩展长度攻击demo"></a>hash扩展长度攻击demo</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">已知secret为&#x27;secret&#x27;(攻击者未知)</span><br><span class="line">数据data为&#x27;data&#x27;(攻击者已知)</span><br><span class="line">加密方式为MD5(secret+data)此时也可以叫做加盐</span><br><span class="line">追加字符为wann</span><br></pre></td></tr></table></div></figure>
<p>此时按照流程</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">填入数据 --&gt; 填补补位 --&gt; 写入数据长度 --&gt; 补0</span><br></pre></td></tr></table></div></figure>
<p><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/11.png"><br>然后此时攻击者进行追加内容wann<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/12.png"><br>此时在继续计算它的MD5值时便有两种方法了</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">法一：直接使用MD5算法计算(服务端采用此方法)</span><br><span class="line">法二：通过第一个块结束开始，使用我们已经从签hash中获得的状态并从该状态开始对追加内容进行hash(攻击者采用)</span><br></pre></td></tr></table></div></figure>

        <h3 id="服务器的计算：">
          <a href="#服务器的计算：" class="heading-link"><i class="fas fa-link"></i></a><a href="#服务器的计算：" class="headerlink" title="服务器的计算："></a>服务器的计算：</h3>
      <p>我们知道服务器会在字符串前面加上secret；所以此时我们向它发送字符串减去secret<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/14.png"><br>服务器在该字符串前面附加密钥<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/12.png"><br>设此时服务器根据签名 6ee582a1669ce442f3719c47430dadee 检查我们发送的数据；那么此时我们作为攻击者需要弄清楚如何生成签名</p>

        <h3 id="攻击者的计算-此时我们从一个问题开始">
          <a href="#攻击者的计算-此时我们从一个问题开始" class="heading-link"><i class="fas fa-link"></i></a><a href="#攻击者的计算-此时我们从一个问题开始" class="headerlink" title="攻击者的计算(此时我们从一个问题开始)"></a>攻击者的计算(此时我们从一个问题开始)</h3>
      <p>假设我们发现了这样的一个下载文件的接口：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/download?name=test.pdf&amp;sig=6543109bb53887f7bb46fe424f26e24a</span><br></pre></td></tr></table></div></figure>
<p>经过测试发现sig可能是这个文件的某种校验签名，如果想通过这个接口下载其他文件就会失败，因为sig的校验无法通过。同时还会发现md5(name) !&#x3D;&#x3D;sig，很明<br>显在校验算法中添加了盐，如果我们想下载任意的文件比如test.pdf%00&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd，正常情况下是没办法的，因为有盐，所以我们无法构造自己<br>的签名值，但是如果服务端使用了类似下面的校验代码，那么就会存在被绕过的风险。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if($sig === md5($salt.name))</span><br></pre></td></tr></table></div></figure>
<p>此时回到我们的hash长度扩展攻击，我们可以利用md5的一些trick绕过这个限制。这个问题实际上变成了：如何在不知道 salt&#x2F;key&#x2F;secret 的情况下，计算出一<br>个文件名的合法 hash 值。<br>此时设这个合法的数据是test.pdf -&gt; 6543109bb53887f7bb46fe424f26e24a<br>攻击<br>1.此时实施攻击的第一步便是将test.pdf这个部分补足到64Byte</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">len(secret) + len(&quot;test.pdf&quot;) + len(padding) + 8 == 64Byte</span><br><span class="line">padding：为补齐的一部分</span><br></pre></td></tr></table></div></figure>
<p>2.假设我们已经知道了 secret 的长度是 10，那么可以计算出，padding 的长度是 64-8-10-8; 这个 padding 中，第一个字节是 “\x80”，所以补0的长度是 64-8-10-8-1&#x3D;37。所以我们的例子就会被补成这个样子：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secret + &quot;test.pdf&quot; + &quot;\x80&quot; + &quot;\x00&quot;*37 + &quot;\x90\x00\x00\x00\x00\x00\x00\x00&quot;</span><br></pre></td></tr></table></div></figure>
<p>3.最后的 8byte 是 len(secret+”test.pdf”)，换成16进制就是\x90。这个长度已经是64Byte了，所以如果再向后面附加内容，那么就是一个新的计算块了。<br>这段过程用代码写出来：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fake_filename = &quot;test.pdf&#123;padding&#125;&quot;</span><br><span class="line">padding = &quot;\x80&#123;zero&#125;\x90\x00\x00\x00\x00\x00\x00\x00&quot;.format(zero=&quot;\x00&quot;*(56-18-1))</span><br><span class="line">fake_filename = fake_filename.format(padding=padding) + &quot;/../../../../etc/passwd&quot;</span><br><span class="line"># print(fake_filename)</span><br><span class="line">print(&quot;fake_filename length: &quot; + str(len(fake_filename)))</span><br></pre></td></tr></table></div></figure>


        <h2 id="从算法方面看hash长度拓展攻击">
          <a href="#从算法方面看hash长度拓展攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#从算法方面看hash长度拓展攻击" class="headerlink" title="从算法方面看hash长度拓展攻击"></a>从算法方面看hash长度拓展攻击</h2>
      
        <h3 id="计算步骤">
          <a href="#计算步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h3>
      <p>依旧是$str&#x3D;”test”<br>此时经过补位后得到</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000</span><br></pre></td></tr></table></div></figure>
<p><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/16.png"><br>此时我们继续在后面加上一个wann</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$str=0x7465737480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000077616e6e</span><br></pre></td></tr></table></div></figure>
<p><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/17.png"><br>此时得$str大于512bit，此时程序会自动将这串数据补为1024bit</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$str=0x7465737480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000077616e6e800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000</span><br></pre></td></tr></table></div></figure>
<p>此时我们将$str分成两部分</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000</span><br></pre></td></tr></table></div></figure>
<p>和</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">77616e6e800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000</span><br></pre></td></tr></table></div></figure>
<p>这个时候程序计算前一部分的ABCD的值</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=0xcd6b8f09</span><br><span class="line">B=0x73d32146</span><br><span class="line">C=0x834edeca</span><br><span class="line">D=0xf6b42726</span><br></pre></td></tr></table></div></figure>
<p>到了第二部分，此时第二部分的计算会使用第一部分的ABCD去计算的；此时可以得到新的ABCD</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A=0x226359e5</span><br><span class="line">b=0x99df12eb</span><br><span class="line">C=0x6853f59e</span><br><span class="line">D=0xf5406385</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>最后算出来的MD5是e5596322eb12df999ef55368856340f5</p>

        <h3 id="发现问题">
          <a href="#发现问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h3>
      <p>我们看到了，将原数据按长度拆分后，第一轮计算的结果会作为幻数用在第二轮计算中。而在我们的问题中，第一轮计算的结果我们是已知的，也就是说，我们知道了第二轮计算的幻数，可以进行接下来的运算。<br>因为知道第一个字符串$a的长度，此时我们就可以构造第二个字符串$b的值；也就是说我们手动在第二个字符串$b的前端添加一些特定数据，使得第一轮计算因为我们添加数据后符合一轮计算的原数据长度而只计算出第一个字符串的hash值。这样我们就可以利用这个结果作为我们二轮计算的幻数进行下面的计算，从而预测最终的md结果。</p>

        <h3 id="md5的hash长度扩展攻击操作实例">
          <a href="#md5的hash长度扩展攻击操作实例" class="heading-link"><i class="fas fa-link"></i></a><a href="#md5的hash长度扩展攻击操作实例" class="headerlink" title="md5的hash长度扩展攻击操作实例"></a>md5的hash长度扩展攻击操作实例</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.$a的MD5(098f6bcd4621d373cade4e832627b4f6)</span><br><span class="line">2.$a的长度=4</span><br><span class="line">3.$b我们可以任意控制</span><br></pre></td></tr></table></div></figure>
<p>由1我们可以推出ABCD的值</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=0xcd6b8f09</span><br><span class="line">B=0x73d32146</span><br><span class="line">C=0x834edeca</span><br><span class="line">D=0xf6b42726</span><br></pre></td></tr></table></div></figure>
<p>我们构造$b的值，在前面添加特定长度的补全值： </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$b=&#x27;\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00&#x27;+&#x27;test&#x27;</span><br><span class="line">ps:</span><br><span class="line">其中\x80\x00\x00\x00\x00\x00\x00\x00这一类的数据是在md5计算的补位过程中填充的数据(padding)</span><br></pre></td></tr></table></div></figure>
<p>此时因为我们不知道$a的具体内容只知道长度；此时我们假设$a&#x3D;”aaaa”;则可以变成</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$str=&#x27;aaaa&#x27;+&#x27;\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00&#x27;+&#x27;test&#x27;</span><br></pre></td></tr></table></div></figure>
<p>然后：<br>1.由于大于512位，先补全为1024位，<br>2.将其分为两部分<br>3.计算第一部分的ABCD的值<br>4.再用第一部分算出来的ABCD拿来算第二部分的值。<br>这里由于第一部分的ABCD我们可以逆推出来，我们可以直接跳过前三部分直接进行第四部分的计算，只需要将标准的MD5的源码里面的初始的ABCD的值改为逆推出来的那个值。<br>此时我们使用初始的(假的)ABCD计算一下下面的MD5</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000</span><br></pre></td></tr></table></div></figure>
<p>可以发现和上面正向计算出来的一样。<br>至此MD5的hash扩展攻击结束</p>

        <h2 id="攻击">
          <a href="#攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2>
      
        <h3 id="攻击的要点在于：">
          <a href="#攻击的要点在于：" class="heading-link"><i class="fas fa-link"></i></a><a href="#攻击的要点在于：" class="headerlink" title="攻击的要点在于："></a>攻击的要点在于：</h3>
      <p>攻击者可以控制message<br>攻击者需要知道key的长度，如不知道可以考虑暴力破解<br>攻击已经知道了包含key的一个消息的hash值<br>hash算法使用了Merkle–Damgård construction进行数据的压缩（比如MD5、SHA-1等）并采取 H(密钥 ∥ 消息) 构造<br>攻击可以达到的效果在于，如果知道一个原消息哈希值H(key∥M1)及其(key∥M1)长度，对于任意的字符串M2，攻击者可以计算出H(pad(key∥M1) + M2)的值，而不需要知道是key及M1是多少<br>利用场景</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 $hash = md5($secret.$key) 中已知 $hash 和 $key 以及 $secret 的长度时  </span><br><span class="line">可以找到另一个 $_hash 和 $_key 使得 $_hash = md5($secrect.$_key) 成立</span><br></pre></td></tr></table></div></figure>

        <h3 id="如何攻击">
          <a href="#如何攻击" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何攻击" class="headerlink" title="如何攻击"></a>如何攻击</h3>
      <p>由于上面我们已经补全过数据了，现在已经是完整的块了，当我们继续在后面补充数据的时候，他在分块的时候就会直接帮我们把前面的数据分块，这部分会被hash算法先计算，由于算法初始值相同，计算的顺序相同，这一块的数据计算的结果就一定是固定的，也就是在我们没有补充数据之前的数据的hash结果，那么只要当我们后面补充的数据用这个hash结果的状态继续往后面执行，计算出来的evil_hash也一定会和服务器端hash(secret+“填充数据”+“任意可控数据”)的最终结果一样。从而可以导致该攻击。<br>更简单的说法是：攻击者的哈希计算过程，相当于从服务器计算过程的一半紧接着进行下去。</p>

        <h3 id="攻击流程">
          <a href="#攻击流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3>
      <p>服务器端：<br>hash(secret+msg) &#x3D;&gt;一系列计算 hash_value<br>攻击者:<br>在知道secret+msg多长的情况下可以补全为一个完整的块，从而补全的这个块计算出来的结果我们可以拿到该状态，然后加入可控的邪恶数据，再利用原来服务器的hash_value来设置当前的hash状态，从而继续执行下去。<br>ps:通常来讲，攻击者不会知道服务器上原始secret的长度，所以可能需要枚举secret的长度直到成功<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/15.png"><br>ps: <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://github.com/CTF-Thanos/ctf-record/blob/master/shiyanbar/ctf1848/hash%E9%95%BF%E5%BA%A6%E6%94%BB%E5%87%BB.md">https://github.com/CTF-Thanos/ctf-record/blob/master/shiyanbar/ctf1848/hash%E9%95%BF%E5%BA%A6%E6%94%BB%E5%87%BB.md</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="hash长度拓展攻击在ctf中的考点">
          <a href="#hash长度拓展攻击在ctf中的考点" class="heading-link"><i class="fas fa-link"></i></a><a href="#hash长度拓展攻击在ctf中的考点" class="headerlink" title="hash长度拓展攻击在ctf中的考点"></a>hash长度拓展攻击在ctf中的考点</h2>
      <p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="http://ctf5.shiyanbar.com/web/kzhan.php">http://ctf5.shiyanbar.com/web/kzhan.php</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>源码审计<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/18.png"><br>此时的重点在于<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/19.png"><br>此时通过$COOKIE[“getmein”]来获取名为getmein的Cookie值；后面的md5($secret.urldecode($username.$password))是对一个秘密字符串和经过url解码<br>的username和password连接而成的字符串进行md5加密<br>然后根据<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/20.png"><br>我们可以知道第一个hash值：571580b26c65f306376d4f64e53cb5c7<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/21.png"><br>然后根据hash扩展长度攻击我们即可伪造出第二个hash<br>已知信息</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">secret的长度为15，再加上第一个admin就是20</span><br><span class="line">哈希值为571580b26c65f306376d4f64e53cb5c7</span><br><span class="line">data为第二个admin</span><br><span class="line">add数据为任意</span><br></pre></td></tr></table></div></figure>
<p>此时我们使用hashpump来帮助我们生成payload<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/22.png"><br>此时利用chatgpt帮助我们把\x全部替换成%：admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00hey<br><img src="/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/23.png"><br>此时即可完成hash扩展长度攻击得到flag<br>原理：在知道secret+msg多长的情况下可以补全为一个完整的块，从而补全的这个块计算出来的结果我们可以拿到该状态，然后加入可控的邪恶数据，再利用原来服务器的hash_value来设置当前的hash状态，从而继续执行下去。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="https://hyggevv.github.io">hey</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/">https://hyggevv.github.io/2023/06/27/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2023/07/11/2023%E9%97%BD%E7%9B%BE%E7%BA%BF%E4%B8%8B%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83%E5%B0%8F%E8%AE%B0/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">2023闽盾线下攻防演练复盘</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2023/06/26/pop%E9%93%BE%E4%B9%8Bphar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"><span class="paginator-prev__text">pop链之phar反序列化</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E7%AE%97%E6%B3%95%E5%92%8Chash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB"><span class="toc-number">1.</span> <span class="toc-text">
          hash算法和hash长度拓展攻击</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MD5%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">
          MD5算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MD5%E5%8A%A0%E5%AF%86"><span class="toc-number">1.</span> <span class="toc-text">
          MD5加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MD5%E7%AE%97%E6%B3%95-1"><span class="toc-number">2.</span> <span class="toc-text">
          MD5算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86MD5%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">
          初识MD5算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5MD5%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">
          深入MD5算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MD5%E5%8A%A0%E5%AF%86demo%E6%B5%8B%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">
          MD5加密demo测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E7%AE%97%E6%B3%95%E6%96%B9%E9%9D%A2%E7%9C%8BMD5%E5%8A%A0%E5%AF%86"><span class="toc-number">4.</span> <span class="toc-text">
          从算法方面看MD5加密</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB"><span class="toc-number"></span> <span class="toc-text">
          hash长度拓展攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E6%89%A9%E5%B1%95%E9%95%BF%E5%BA%A6%E6%94%BB%E5%87%BBdemo"><span class="toc-number">1.</span> <span class="toc-text">
          hash扩展长度攻击demo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%AE%A1%E7%AE%97%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">
          服务器的计算：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E8%80%85%E7%9A%84%E8%AE%A1%E7%AE%97-%E6%AD%A4%E6%97%B6%E6%88%91%E4%BB%AC%E4%BB%8E%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E5%BC%80%E5%A7%8B"><span class="toc-number">1.2.</span> <span class="toc-text">
          攻击者的计算(此时我们从一个问题开始)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E7%AE%97%E6%B3%95%E6%96%B9%E9%9D%A2%E7%9C%8Bhash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB"><span class="toc-number">2.</span> <span class="toc-text">
          从算法方面看hash长度拓展攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.1.</span> <span class="toc-text">
          计算步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">
          发现问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#md5%E7%9A%84hash%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">
          md5的hash长度扩展攻击操作实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB"><span class="toc-number">3.</span> <span class="toc-text">
          攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E7%9A%84%E8%A6%81%E7%82%B9%E5%9C%A8%E4%BA%8E%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">
          攻击的要点在于：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%BB%E5%87%BB"><span class="toc-number">3.2.</span> <span class="toc-text">
          如何攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">
          攻击流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%E5%9C%A8ctf%E4%B8%AD%E7%9A%84%E8%80%83%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">
          hash长度拓展攻击在ctf中的考点</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/usually.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">hey</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">120</div><div class="sidebar-ov-state-item__name">Archives</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Categories</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Tags</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>hey</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.4.2</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div><div class="busuanzi"><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">Views</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":180,"height":300},"mobile":{"show":true},"log":false});</script></body></html>