<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.7.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.7.0" type="image/png" sizes="32x32"><meta name="description" content="在学习Java反序列化漏洞的时候，经常会遇到RMI、JNDI、JRMP这些概念，其中RMI是一个基于序列化的Java远程方法调用机制。作为一个常见的反序列化入口，它和反序列化漏洞有着千丝万缕的联系。除了直接攻击RMI服务接口外（比如CVE-2017-3241），我们在构造反序列化漏洞利用时也可以结合RMI方便的实现远程代码执行。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSec-Remote Method Invocation">
<meta property="og:url" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/index.html">
<meta property="og:site_name" content="hey&#39;s blog">
<meta property="og:description" content="在学习Java反序列化漏洞的时候，经常会遇到RMI、JNDI、JRMP这些概念，其中RMI是一个基于序列化的Java远程方法调用机制。作为一个常见的反序列化入口，它和反序列化漏洞有着千丝万缕的联系。除了直接攻击RMI服务接口外（比如CVE-2017-3241），我们在构造反序列化漏洞利用时也可以结合RMI方便的实现远程代码执行。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/1.jpg">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/2.png">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/3.png">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/6.png">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/7.png">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/4.png">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/5.png">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/8.png">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/9.png">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/10.png">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/11.png">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/12.png">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/13.png">
<meta property="og:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/14.png">
<meta property="article:published_time" content="2024-01-31T08:19:30.000Z">
<meta property="article:modified_time" content="2024-02-16T12:29:08.397Z">
<meta property="article:author" content="hey">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/1.jpg"><title>JavaSec-Remote Method Invocation | hey's blog</title><link ref="canonical" href="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.7.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copiar","copySuccess":"Éxito en copia","copyError":"Error en copia"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Inicio</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archivos</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">Categorías</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">Etiquetas</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">Sobre Nosotros</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/read/"><span class="header-nav-menu-item__icon"><i class="fas fa-book"></i></span><span class="header-nav-menu-item__text">menu.read</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">hey's blog</div><div class="header-banner-info__subtitle">天气转晴太阳崭新我在前进</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">JavaSec-Remote Method Invocation</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Creado</span><span class="post-meta-item__value">2024-01-31</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Actualizado</span><span class="post-meta-item__value">2024-02-16</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">Visitado</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body">
        <h1 id="学习大纲">
          <a href="#学习大纲" class="heading-link"><i class="fas fa-link"></i></a><a href="#学习大纲" class="headerlink" title="学习大纲"></a>学习大纲</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 关于RMI</span><br><span class="line">	<span class="number">1.1</span>. RMI概述</span><br><span class="line">	<span class="number">1.2</span>. RMI的三层架构</span><br><span class="line">	<span class="number">1.3</span>. Stubs and Skeletons</span><br><span class="line">	<span class="number">1.4</span>. RMI的运行机制</span><br><span class="line"><span class="number">2.</span> Remote Method Invocation</span><br><span class="line">	<span class="number">2.1</span>. 远程对象</span><br><span class="line">		<span class="number">2.1</span><span class="number">.1</span>. 继承UnicastRemoteObject的时候构造函数</span><br><span class="line">			<span class="number">2.1</span><span class="number">.1</span><span class="number">.1</span>. tips</span><br><span class="line">		<span class="number">2.1</span><span class="number">.2</span>. 没有继承UnicastRemoteObject的时候构造函数</span><br><span class="line">		<span class="number">2.1</span><span class="number">.3</span>. IHello.java</span><br><span class="line">			<span class="number">2.1</span><span class="number">.3</span><span class="number">.1</span>. tips</span><br><span class="line">	<span class="number">2.2</span>. 对象调用过程</span><br><span class="line">		<span class="number">2.2</span><span class="number">.1</span>. 本地对象的调用</span><br><span class="line">		<span class="number">2.2</span><span class="number">.2</span>. 远程对象的调用</span><br><span class="line">	<span class="number">2.3</span>. RMI Registry</span><br><span class="line">		<span class="number">2.3</span><span class="number">.1</span>. RMI Registry的注册</span><br><span class="line">		<span class="number">2.3</span><span class="number">.2</span>. RMI Registry的使用</span><br><span class="line"><span class="number">3.</span> RMI的简单实现</span><br><span class="line">	<span class="number">3.1</span>. Server</span><br><span class="line">		<span class="number">3.1</span><span class="number">.1</span>. 接口实现</span><br><span class="line">		<span class="number">3.1</span><span class="number">.2</span>. 创建类用于远程调用</span><br><span class="line">		<span class="number">3.1</span><span class="number">.3</span>. 实现调用</span><br><span class="line">			<span class="number">3.1</span><span class="number">.3</span><span class="number">.1</span>. java.rmi.Naming</span><br><span class="line">			<span class="number">3.1</span><span class="number">.3</span><span class="number">.2</span>. 注册</span><br><span class="line">		<span class="number">3.1</span><span class="number">.4</span>. 服务器端完整代码</span><br><span class="line">			<span class="number">3.1</span><span class="number">.4</span><span class="number">.1</span>. IHello.java</span><br><span class="line">			<span class="number">3.1</span><span class="number">.4</span><span class="number">.2</span>. RMIServer.java</span><br><span class="line">	<span class="number">3.2</span>. Client</span><br><span class="line">		<span class="number">3.2</span><span class="number">.1</span>. 客户端完整代码</span><br><span class="line">			<span class="number">3.2</span><span class="number">.1</span><span class="number">.1</span>. IHello.java</span><br><span class="line">			<span class="number">3.2</span><span class="number">.1</span><span class="number">.2</span>. RMIClient.java</span><br><span class="line"><span class="number">4.</span> JRMP协议分析</span><br><span class="line">	<span class="number">4.1</span>. 第一条TCP链接</span><br><span class="line">	<span class="number">4.2</span>. 第二条TCP链接</span><br><span class="line">	<span class="number">4.3</span>. 两条TCP链接分别断开</span><br></pre></td></tr></table></div></figure>


        <h1 id="关于RMI">
          <a href="#关于RMI" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于RMI" class="headerlink" title="关于RMI"></a>关于RMI</h1>
      
        <h2 id="RMI概述">
          <a href="#RMI概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#RMI概述" class="headerlink" title="RMI概述"></a>RMI概述</h2>
      <p><strong>RMI-Remote Method Invocation</strong>顾名思义即为<code>Java</code>的远程方法调用；是基于注册中心和服务来进行实现；可以用于实现微服务。<code>RMI</code>用于构建分布式应用程序，<code>RMI</code>实现了<code>Java</code>程序之间跨<code>JVM</code>的远程通信。</p>
<p><img src="/2024/01/31/JavaSec-RMI/1.jpg"></p>
<p>它的功能是让<code>Java</code>的某一台虚拟机<strong>调用另外一台虚拟机中对象的方法</strong>，是<code>Java</code>独有的另一种机制。非常的灵活；再一次的为攻击者提供了方便。</p>
<p>在网络传输过程中，<strong>RMI的对象是通过序列化的方式进行编码传输的</strong>，这也就意味着<strong>RMI在接受到序列化编码的对象之后会进行反序列化</strong>。</p>

        <h2 id="RMI的三层架构">
          <a href="#RMI的三层架构" class="heading-link"><i class="fas fa-link"></i></a><a href="#RMI的三层架构" class="headerlink" title="RMI的三层架构"></a>RMI的三层架构</h2>
      <p><strong>RMI是由三层架构模式来实现的</strong></p>
<ul>
<li><strong>Client-客户端</strong>：客户端调用服务端的方法</li>
<li><strong>Server-服务端</strong>：远程方法调用的提供者，也是代码执行真正的地方。在执行结束之后会返回一个代码的执行结果给客户端</li>
<li><strong>Registry-注册中心</strong>：用于客户端查询要调用的方法的引用；其本质是<strong>map</strong>（相当于字典）</li>
</ul>

        <h2 id="Stubs-and-Skeletons">
          <a href="#Stubs-and-Skeletons" class="heading-link"><i class="fas fa-link"></i></a><a href="#Stubs-and-Skeletons" class="headerlink" title="Stubs and Skeletons"></a>Stubs and Skeletons</h2>
      <p><img src="/2024/01/31/JavaSec-RMI/2.png"></p>
<p>而为了屏蔽网络通信的复杂性时，RMI引入了两个概念，分别是<strong>Stubs（客户端存根）</strong>以及<strong>Skeletons（服务端骨架）</strong>，当客户端试图调用一个远端的对象时，实际调用的是客户端本地的一个代理类（Proxy），这个代理类就称为<strong>Stub</strong>，而在调用远端的目标类之前也会经过一个对应的代理类<strong>Skeletons</strong>，它从<strong>Stub</strong>中接收远程方法调用并传递给真实的类。<strong>Stubs</strong> 以及 <strong>Skeletons</strong> 的调用对于 <code>RMI</code> 服务的使用者来讲是隐藏的，我们无需主动的去调用相关的方法。但实际的客户端和服务端的网络通信时通过 <strong>Stub</strong> 和 <strong>Skeleton</strong> 来实现的。</p>

        <h2 id="RMI的运行机制">
          <a href="#RMI的运行机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#RMI的运行机制" class="headerlink" title="RMI的运行机制"></a>RMI的运行机制</h2>
      <p>调用的机制大概如下：</p>
<ul>
<li><strong>RMI客户端</strong>在调用远程方式是会先创建<code>Stub(sun.rmi.registryImpl_Stub)</code></li>
<li><code>Stub</code>会将Remote对象传递给<code>远程引用层（java.rmi.server.RemoteRef）</code>并创建<code>java.rmi,server.RemoteCall(远程调用)</code>对象</li>
<li><strong>RMI客户端</strong>的远程引用层传输<code>RemoteCall</code>序列化后的请求信息通过<code>Socket</code>连接的方法传输到<strong>RMI服务端的远程引用层</strong></li>
<li><strong>RMI客户端</strong>的<code>远程引用层（sum.rmi.server.UnicasServerRef）</code>收到请求会请求传输给<code>Skeleton(sun.rmi.registery.RegisterImpl_Skel#diapatch)</code></li>
<li><code>Skeleton</code>调用客户端请求：<code>bind</code>、<code>list</code>、<code>lookup</code>、<code>rebind</code>、<code>unbind</code>，如果是<code>lookup</code>则查找<code>RMI服务名</code>绑定的接口对象，序列化该对象并通过<code>RemoteCall</code>传输到客户端。</li>
<li><strong>RMI客户端</strong>反序列化服务端结果，获取远程对象的引用</li>
<li><strong>RMI客户端</strong>调用远程方法，<code>RMI服务端</code>反射调用<code>RMI服务实现类</code>的对应方法并序列化执行结果返回给客户端。</li>
<li><strong>RMI客户端</strong>反序列化<code>RMI</code>远程方法调用结果。</li>
</ul>
<p><img src="/2024/01/31/JavaSec-RMI/3.png"></p>
<p><code>RMI Registry</code>就像⼀个<strong>⽹关</strong>，他⾃⼰是不会执⾏远程⽅法的，但<code>RMI Server</code>可以在上⾯注册⼀个<code>Name</code> 到对象的绑定关系；<code>RMI Client</code>通过<code>Name</code>向<code>RMI Registry</code>查询，得到这个绑定关系，然后再连接<code>RMI Server</code>；最后，远程⽅法实际上在<code>RMI Server</code>上调⽤。</p>

        <h1 id="Remote-Method-Invocation">
          <a href="#Remote-Method-Invocation" class="heading-link"><i class="fas fa-link"></i></a><a href="#Remote-Method-Invocation" class="headerlink" title="Remote Method Invocation"></a>Remote Method Invocation</h1>
      
        <h2 id="远程对象">
          <a href="#远程对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#远程对象" class="headerlink" title="远程对象"></a>远程对象</h2>
      <p>使用远程方法调用，必然会涉及参数的传递和执行结果的返回。参数或者返回值可以是基本数据类型，当然也有可能是对象的引用。所以这些需要被传输的对象必须可以被序列化，这要求相应的类必须实现<code>java.io.Serializable</code>接口，并且客户端的<code>serialVersionUID</code>字段要与服务器端保持一致。</p>
<p>任何可以被远程调用方法的对象必须继承<code>java.rmi.Remote</code>接口，远程对象的实现类必须继承<code>UnicastRemoteObject</code>类（这个类用于实现远程对象。一个类通过继承<code>UnicastRemoteObject</code>并实现一个或多个远程接口，可以成为一个远程服务对象，能够接收远程方法调用。）。如果不继承<code>UnicastRemoteObject</code>类，则需要手工初始化远程对象，在远程对象的构造方法的调用<code>UnicastRemoteObject.exportObject()</code>静态方法，如下：</p>
<p><strong>java.rmi.RemoteException</strong>：<code>RemoteException</code>是一个受检查的异常，<strong>表示在<code>RMI</code>调用过程中可能发生的异常情况</strong>；当远程方法抛出<code>RemoteException</code>时它会被传递给客户端，以便客户端可以捕获处理该异常。在<code>RMI</code>中，远程接口的方法必须声明 可能抛出<code>RemoteException</code>。</p>
<p><strong>java.rmi.server.UnicastRemoteObject</strong>：<code>UnicastRemoteObject</code>是实现远程对象的基类，它提供了<strong>将对象导出为远程对象的功能</strong>。当一个类继承自<code>UnicastRemoteObject</code>并实现了一个远程接口时，该类的实例可以被注册和访问作为远程对象。</p>

        <h3 id="继承UnicastRemoteObject的时候构造函数">
          <a href="#继承UnicastRemoteObject的时候构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#继承UnicastRemoteObject的时候构造函数" class="headerlink" title="继承UnicastRemoteObject的时候构造函数"></a>继承UnicastRemoteObject的时候构造函数</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.rmi;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIHello</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">IHello</span>&#123;</span><br><span class="line"><span class="comment">//定义了一个名为 RMIHello 的类，该类继承自 UnicastRemoteObject 类，并实现了 IHello 接口。</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">RMIHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line"><span class="comment">//定义了一个受保护的构造函数 RMIHello()，它声明可能抛出 RemoteException 异常，通过调用父类的UnicastRemoteObject的无参构造函数来实例化 RMIHello 对象。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hey&quot;</span>;</span><br><span class="line"><span class="comment">//实现了 IHello 接口中的 sayHello 方法。该方法接收一个 name 参数，并返回一个字符串。在方法体内，它打印出 &quot;Hello World!&quot; 消息，并返回字符串 &quot;hey&quot;。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tips">
          <a href="#tips" class="heading-link"><i class="fas fa-link"></i></a><a href="#tips" class="headerlink" title="tips"></a>tips</h4>
      <p>此时上述代码定义了一个<strong>RMIHello</strong>类为远程对象，此时该远程对象继承了<strong>UnicastRemoteObject</strong>类并实现了<strong>IHello</strong>类。此时它的构造函数用于初始化对象并提供一个打印功能然后返回字符串。</p>

        <h3 id="没有继承UnicastRemoteObject的时候构造函数">
          <a href="#没有继承UnicastRemoteObject的时候构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#没有继承UnicastRemoteObject的时候构造函数" class="headerlink" title="没有继承UnicastRemoteObject的时候构造函数"></a>没有继承UnicastRemoteObject的时候构造函数</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.rmi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">IHello</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIHello</span>(); <span class="comment">// 创建远程对象</span></span><br><span class="line">            <span class="type">IHello</span> <span class="variable">stub</span> <span class="operator">=</span> (IHello) UnicastRemoteObject.exportObject(remoteObj, <span class="number">0</span>); <span class="comment">// 导出远程对象</span></span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(); <span class="comment">// 获取 RMI 注册表</span></span><br><span class="line">            registry.bind(<span class="string">&quot;Hello&quot;</span>, stub); <span class="comment">// 将远程对象注册到 RMI 注册表中</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Server ready!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Server exception: &quot;</span> + e.toString());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RMIHello</span> <span class="keyword">implements</span> <span class="title class_">IHello</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RMIHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="comment">// 在没有继承UnicastRemoteObject的时候构造函数也可以写成如下形式</span></span><br><span class="line">        UnicastRemoteObject.exportObject(<span class="built_in">this</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hey&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="IHello-java">
          <a href="#IHello-java" class="heading-link"><i class="fas fa-link"></i></a><a href="#IHello-java" class="headerlink" title="IHello.java"></a>IHello.java</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.rmi;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="comment">//定义了一个接口 IHello，它扩展了 Remote 接口。通过扩展 Remote 接口，表明该接口是一个 RMI 远程接口。</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="comment">//在接口中定义了一个方法 sayHello，它接受一个字符串参数 name，并返回一个字符串。方法声明中使用了 throws RemoteException，表示该方法可能抛出 RemoteException 异常，这是 RMI 中常见的远程调用异常。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tips-1">
          <a href="#tips-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#tips-1" class="headerlink" title="tips"></a>tips</h4>
      <p>这段代码定义了一个<strong>RMI</strong>的远程接口<code>IHello</code>，其中包含了一个方法<code>sayHello</code>，客户端可以通过该方法向远程对象发送消息并获取返回接口。</p>
<p><code>IHello</code>是客户端和服务端共用的接口（客户端本地必须有远程对象的接口，不然无法指定要调用的方法，而且其<strong>全限定名</strong>必须与服务器上的对象完全相同），<code>RMIHello</code>是一个服务端远程对象，提供了一个<code>sayHello</code>方法供远程调用。</p>
<p>以上就构成了RMI Server</p>
<ul>
<li>一个继承了<code>java.rmi.Remote</code>的接口<code>IHello</code>，内部定义了我们将要远程调用的对象方法<code>sayHello()</code></li>
<li>一个实现了此接口的类<code>RMIHello</code></li>
<li>一个主类<code>RMIServer</code>，用来创建<code>Registry</code>，并将类<code>RMIHello</code>实例化后绑定到一个地址</li>
</ul>

        <h2 id="对象调用过程">
          <a href="#对象调用过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象调用过程" class="headerlink" title="对象调用过程"></a>对象调用过程</h2>
      
        <h3 id="本地对象的调用">
          <a href="#本地对象的调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#本地对象的调用" class="headerlink" title="本地对象的调用"></a>本地对象的调用</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectClass</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectClass</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">retn</span> <span class="operator">=</span> objectA.Method();</span><br></pre></td></tr></table></div></figure>


        <h3 id="远程对象的调用">
          <a href="#远程对象的调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#远程对象的调用" class="headerlink" title="远程对象的调用"></a>远程对象的调用</h3>
      <p>但是如果对象在<strong>JVM A</strong>上，而客户端在<strong>JVM B</strong>上；那么此时B如何访问A的对象呢？此时就需要利用到RMI机制了</p>
<p>在JVM之间通信时，RMI对远程对象和非远程对象的处理方式是不一样的，它并没有直接把远程对象复制一份传递给客户端，而是传递了一个远程对象的Stub（存根），Stub相当于远程对象的引用或者代理。Stub对开发者是透明的，客户端可以像调用本地方法一样直接通过它来调用远程方法。Stub中包含了远程对象的定位信息，如Socket端口、服务端主机地址等等，并实现了远程调用过程中具体的底层网络通信细节。而位于服务器端的Skeleton（骨架）,能够读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值。所以RMI远程调用逻辑大致是这样的</p>
<p><img src="/2024/01/31/JavaSec-RMI/6.png"></p>
<p>从逻辑上来看，数据是在Client和Server之间横向流动的，但是<strong>实际上是从Client到Stub，然后从Skeleton到Server这样纵向流动的</strong>。</p>
<p>具体的通信流程如下</p>
<ul>
<li>Server监听一个端口，这个端口是JVM随机选择的</li>
<li>Client并不知道Server远程对象的通信地址和端口，但是位于Client的Stub中包含了这些信息，并封装了底层网络操作。Client可以调用Stub上的方法，并且也可以向Stub发送方法参数。</li>
<li>Stub连接到Server监听的通信端口并提交参数</li>
<li>Server执行具体的方法，并将结果返回给Stub</li>
<li>Stub返回执行结果给Client。因此在Clinet看来，就好像是Stub在本地执行了这个方法。</li>
</ul>
<p>那么问题来了，位于Client上的Stub是怎么获取到远程Server的通信信息的呢？这就需要使用RMI Registry了。</p>

        <h2 id="RMI-Registry">
          <a href="#RMI-Registry" class="heading-link"><i class="fas fa-link"></i></a><a href="#RMI-Registry" class="headerlink" title="RMI Registry"></a>RMI Registry</h2>
      
        <h3 id="RMI-Registry的注册">
          <a href="#RMI-Registry的注册" class="heading-link"><i class="fas fa-link"></i></a><a href="#RMI-Registry的注册" class="headerlink" title="RMI Registry的注册"></a>RMI Registry的注册</h3>
      <p>JDK提供了一个RMI注册表（RMI Registry）来解决这个问题。RMI Registry也是一个远程对象，默认监听在1099端口上，可以使用代码启动RMI Registry，也可以使用rmiregistry命令。</p>
<p>要注册远程对象，需要RMI URL和一个远程对象的引用</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//这是一个私有方法 register()，声明了一个可能抛出异常的方法，需要在调用处进行异常处理或继续抛出。</span></span><br><span class="line">        RMIHello rmiHello=<span class="keyword">new</span> <span class="title class_">RMIHello</span>();</span><br><span class="line">    <span class="comment">//创建一个 RMIHello 的实例对象 rmiHello。RMIHello 是一个远程对象，通过此实例可以在远程上提供服务。</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">    <span class="comment">//在本地创建一个 RMI 注册表，使用默认端口 1099。RMI 注册表用于存储远程对象的引用，客户端可以通过指定名称来查找和访问这些远程对象。</span></span><br><span class="line">        Naming.bind(<span class="string">&quot;rmi://127.0.0.1:1099/hello&quot;</span>,rmiHello);</span><br><span class="line">    <span class="comment">//通过 Naming.bind() 方法将远程对象 rmiHello 绑定到指定的 RMI URL 上。这里的 URL 是 &quot;rmi://127.0.0.1:1099/hello&quot;，表示绑定到本地 IP 地址为 127.0.0.1，端口为 1099 的 RMI 注册表上，并使用名称 &quot;hello&quot; 标识该远程对象。绑定后，客户端可以使用该 URL 和名称来查找并访问远程对象。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>在主类的<code>register()</code>方法中，我们首先实例化了一个将被远程调用的类<code>RMIHello</code>，然后使用 <code>LocateRegistry.createRegistry(port)</code>在本地的某个端口上创建了一个<code>Registry</code>。最后使用<code>Naming.bind()</code>将实例化对象和地址上的<code>hello</code>绑定在一起，作为远程对象的名字。注意这里使用的是<code>rmi://</code>协议。这样，我们就完成了对RMI Registry的注册。</p>

        <h3 id="RMI-Registry的使用">
          <a href="#RMI-Registry的使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#RMI-Registry的使用" class="headerlink" title="RMI Registry的使用"></a>RMI Registry的使用</h3>
      <p>注册完RMI Registry以后，我们将要调用的远程对象已经和服务器端的某个地址绑定在了一起。那么Clinet又是怎么从Registry获取服务器远程对象信息的呢？我们创建一个简单的RMI Client，代码如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.rmi;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Registry registry= LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        IHello iHello=(IHello) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">//通过 registry.lookup() 方法查找指定名称为 &quot;hello&quot; 的远程对象，并将其转换为 IHello 接口类型的引用。这里假设已经在远程注册表上绑定了名称为 &quot;hello&quot; 的远程对象。</span></span><br><span class="line">        System.out.println(iHello.sayHello(<span class="string">&quot;hey&quot;</span>));</span><br><span class="line">        <span class="comment">//调用 iHello 引用的远程对象的 sayHello() 方法，传入字符串参数 &quot;hey&quot;，并将返回结果打印输出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>LocateRegistry.getRegistry()</code>会使用给定的主机和端口等信息在本地创建一个<code>Stub</code>对象作为Registry远程对象的代理，从而启动整个远程调用逻辑。服务端应用程序可以向RMI注册表中注册远程对象，然后客户端向RMI注册表查询某个远程对象名称，来获取该远程对象的Stub。这里我们使用了<code>registry.lookup()</code>来查询获取注册表中的远程对象。还有另一种写法：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        </span><br><span class="line">        System.out.println(iHello.sayHello(<span class="string">&quot;hhheey&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>使用了RMI Registry后，RMI的调用关系如下：</p>
<p><img src="/2024/01/31/JavaSec-RMI/7.png"></p>

        <h1 id="RMI的简单实现">
          <a href="#RMI的简单实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#RMI的简单实现" class="headerlink" title="RMI的简单实现"></a>RMI的简单实现</h1>
      
        <h2 id="Server">
          <a href="#Server" class="heading-link"><i class="fas fa-link"></i></a><a href="#Server" class="headerlink" title="Server"></a>Server</h2>
      <p>一个<code>RMIServer</code>分为三部分</p>
<ul>
<li>一个继承了<code>java.rmi.Remote</code>接口，其中定义了我们要远程调用的函数，比如在这个例子中的<code>hello()</code></li>
<li>一个实现接口的类</li>
<li>一个主类，用来创建<code>Registry</code>，并将上面的类实例化后绑定到一个地址，这也就是我们所谓的<strong>Server</strong></li>
</ul>

        <h3 id="接口实现">
          <a href="#接口实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3>
      <p>首先是接口实现并继承<strong>Remote</strong>；并在里面创建一个<code>hello()</code>方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title class_">Remote</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="创建类用于远程调用">
          <a href="#创建类用于远程调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建类用于远程调用" class="headerlink" title="创建类用于远程调用"></a>创建类用于远程调用</h3>
      <p>然后创建一个类去实现这个接口用于远程调用；继承<code>UnicastRemoteObject</code>类后会使用默认<code>socket</code>进行通讯，并且该类会一直运行在服务器上。如果不继承<code>UnicastRemoteObject</code>类，则需要手工初始化对象，在远程对象的构造方法的调用<code>UnicasrReomteObject.exportObject()</code>静态方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.RMI;  <span class="comment">//包声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;  <span class="comment">//导入必需的类；UnicastRemoteObject：用于导出远程对象并使它们能够接收远程方法调用的类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">IRemoteHelloWorld</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">RMIServer</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>此时我们将重点放在类的继承和接口的实现</p>
<p><img src="/2024/01/31/JavaSec-RMI/4.png"></p>
<p>此时<code>RMIServer</code>类继承了<code>UnicastRemoteObject</code>使得该类称为远程对象，能够接受远程调用；并且此时实现了<code>IRemoteHelloWorld</code>接口；这个接口继承<code>java.rmi.remote</code>，定义了可以远程调用的方法。这意味着<code>RMIServer</code>必需提供<code>IRemoteHelloWorld</code>接口的中所声明的方法的实现</p>
<p>接下来把目光放到实现远程方法</p>
<p><img src="/2024/01/31/JavaSec-RMI/5.png"></p>
<p>在这里<code>RMIServer</code>实现了<code>IRemoteHelloWorld</code>接口的<code>hello()</code>方法；当客户端调用这个方法时会返回<code>hello world</code>。方法使用<code>@Override</code>注解标记，这表明该方法覆盖或实现了父类或接口中的方法。</p>

        <h3 id="实现调用">
          <a href="#实现调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现调用" class="headerlink" title="实现调用"></a>实现调用</h3>
      <p>现在可以被远程调用的对象创建好了，接下来就是考虑如何调用了。</p>
<p>在<strong>Java RMI</strong>中设计了一个<strong>Registry</strong>的思想，很好理解我们可以使用注册表来查找一个远程对象的使用。通俗来说这就是一个RMI电话本，当我们想在某个人那里获取信息时<code>（Remote Method Invocation）</code>就在电话本<code>Registry</code>中通过这个人的名称<code>Name</code>中来找到这个人的电话<code>Reference</code>，并通过这个电话找到这个人<code>Remote Object</code>。</p>
<p>这种电话本的思想，由 <code>java.rmi.registry.Registry</code> 和 <code>java.rmi.Naming</code> 来实现。这里分别来说说这两个东西。</p>

        <h4 id="java-rmi-Naming">
          <a href="#java-rmi-Naming" class="heading-link"><i class="fas fa-link"></i></a><a href="#java-rmi-Naming" class="headerlink" title="java.rmi.Naming"></a>java.rmi.Naming</h4>
      <p><code>java.rmi.Naming</code>提供了在远程注册表（Registry）中存储和获取远程对象的方法。这个类提供的每个方法都有一个 URL 格式的参数，格式如下：<code> //host:port/name</code>：</p>
<ul>
<li>host 表示注册表所在的主机</li>
<li>port 表示注册表接受调用的端口号，默认为 1099</li>
<li>name 表示一个注册 Remote Object 的引用的名称，不能是注册表中的一些关键字</li>
</ul>
<p>那么这样就好理解了，我们现在实现了服务端待调用的对象，现在我们要把他装载进“电话本”，也就是注册（registry）</p>

        <h4 id="注册">
          <a href="#注册" class="heading-link"><i class="fas fa-link"></i></a><a href="#注册" class="headerlink" title="注册"></a>注册</h4>
      <ol>
<li>利用<code>LocateRegistry.createRegistry(1099);</code>创建注册中心</li>
<li>实例化远程对象</li>
<li>把这个实例化对象绑定name存入“电话本”</li>
</ol>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.RMI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, MalformedURLException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="comment">//创建注册中心</span></span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//创建远程对象</span></span><br><span class="line">        <span class="type">RMIObject</span> <span class="variable">rmiObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIObject</span>();</span><br><span class="line">        <span class="comment">// 绑定name</span></span><br><span class="line">        Naming.bind(<span class="string">&quot;rmi://localhost:1099/Hello&quot;</span>, rmiObject);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="服务器端完整代码">
          <a href="#服务器端完整代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#服务器端完整代码" class="headerlink" title="服务器端完整代码"></a>服务器端完整代码</h3>
      
        <h4 id="IHello-java-1">
          <a href="#IHello-java-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#IHello-java-1" class="headerlink" title="IHello.java"></a>IHello.java</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.rmi;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="RMIServer-java">
          <a href="#RMIServer-java" class="heading-link"><i class="fas fa-link"></i></a><a href="#RMIServer-java" class="headerlink" title="RMIServer.java"></a>RMIServer.java</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.rmi;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIHello</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">RMIHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        RMIHello rmiHello=<span class="keyword">new</span> <span class="title class_">RMIHello</span>();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Naming.bind(<span class="string">&quot;rmi://0.0.0.0:1099/hello&quot;</span>,rmiHello);</span><br><span class="line">        System.out.println(<span class="string">&quot;Registry运行中......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RMIServer</span>().register();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="Client">
          <a href="#Client" class="heading-link"><i class="fas fa-link"></i></a><a href="#Client" class="headerlink" title="Client"></a>Client</h2>
      <ol>
<li>使用<code>Naming</code> 在<code>Registry</code>中寻找到名字是Hello的对象</li>
<li>调用远程对象的方法属性</li>
</ol>
<p><strong>Naming</strong>有很多种方法</p>
<p><img src="/2024/01/31/JavaSec-RMI/8.png"></p>
<p>这里用<strong>lookup</strong>来测试，他返回：<code>a reference for a remote object</code>，远程对象的引用</p>
<ul>
<li>此<code>Naming.lookup()</code>调用检查在 localhost 中运行的 RMI 注册表中是否存在名为“Hello”的绑定</li>
<li>它返回一个必须转换为我期望的任何远程接口的对象</li>
<li>然后就可以使用该对象调用接口中定义的远程方法</li>
</ul>

        <h3 id="客户端完整代码">
          <a href="#客户端完整代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#客户端完整代码" class="headerlink" title="客户端完整代码"></a>客户端完整代码</h3>
      
        <h4 id="IHello-java-2">
          <a href="#IHello-java-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#IHello-java-2" class="headerlink" title="IHello.java"></a>IHello.java</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.rmi;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="RMIClient-java">
          <a href="#RMIClient-java" class="heading-link"><i class="fas fa-link"></i></a><a href="#RMIClient-java" class="headerlink" title="RMIClient.java"></a>RMIClient.java</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> learn.rmi;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Registry registry= LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        IHello iHello=(IHello) registry.lookup(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(iHello.sayHello(<span class="string">&quot;hhheey&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="JRMP协议分析">
          <a href="#JRMP协议分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#JRMP协议分析" class="headerlink" title="JRMP协议分析"></a>JRMP协议分析</h1>
      <p><code>Java远程方法协议（Java Remote Method Protocol，JRMP）</code>是<strong>特定于Java技术的、用于查找和引用远程对象的协议</strong>。这是运行在<code>Java远</code>程方法调用（RMI）之下、<code>TCP/IP</code>之上的线路层协议。</p>

        <h2 id="第一条TCP链接">
          <a href="#第一条TCP链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一条TCP链接" class="headerlink" title="第一条TCP链接"></a>第一条TCP链接</h2>
      <p>首先是<code>TCP三次握手</code>来建立第一条<code>TCP</code>链接，客户端连接服务器的<code>1099</code>端口，这里真正连接到的其实是<code>RMI Registry</code>，然后<strong>二者建立JRMP链接</strong>。</p>
<p><img src="/2024/01/31/JavaSec-RMI/9.png"></p>
<p>随后<code>Clinet</code>向<code>Registry</code>发送<code>”Call”</code>信息，<code>Registry</code>回复<code>”ReturnData”</code>。我们看一下<strong>Registry</strong>的回复内容。</p>
<p><img src="/2024/01/31/JavaSec-RMI/10.png"></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000   00 0c 29 b3 84 37 14 18 c3 e1 a9 29 08 00 45 00  ..)..7.....)..E.</span><br><span class="line">0010   01 62 3d 67 40 00 80 06 00 00 c0 a8 2b a2 c0 a8  .b=g@.......+...</span><br><span class="line">0020   2b 0a 04 4b b5 d0 a1 2c d2 91 8b 75 e2 86 50 18  +..K...,...u..P.</span><br><span class="line">0030   08 04 d9 51 00 00 51 ac ed 00 05 77 0f 01 82 3c  ...Q..Q....w...&lt;</span><br><span class="line">0040   5d f8 00 00 01 7e 4c 4d 6c e9 80 05 73 7d 00 00  ]....~LMl...s&#125;..</span><br><span class="line">0050   00 02 00 0f 6a 61 76 61 2e 72 6d 69 2e 52 65 6d  ....java.rmi.Rem</span><br><span class="line">0060   6f 74 65 00 10 6c 65 61 72 6e 2e 72 6d 69 2e 49  ote..learn.rmi.I</span><br><span class="line">0070   48 65 6c 6c 6f 70 78 72 00 17 6a 61 76 61 2e 6c  Hellopxr..java.l</span><br><span class="line">0080   61 6e 67 2e 72 65 66 6c 65 63 74 2e 50 72 6f 78  ang.reflect.Prox</span><br><span class="line">0090   79 e1 27 da 20 cc 10 43 cb 02 00 01 4c 00 01 68  y.&#x27;. ..C....L..h</span><br><span class="line">00a0   74 00 25 4c 6a 61 76 61 2f 6c 61 6e 67 2f 72 65  t.%Ljava/lang/re</span><br><span class="line">00b0   66 6c 65 63 74 2f 49 6e 76 6f 63 61 74 69 6f 6e  flect/Invocation</span><br><span class="line">00c0   48 61 6e 64 6c 65 72 3b 70 78 70 73 72 00 2d 6a  Handler;pxpsr.-j</span><br><span class="line">00d0   61 76 61 2e 72 6d 69 2e 73 65 72 76 65 72 2e 52  ava.rmi.server.R</span><br><span class="line">00e0   65 6d 6f 74 65 4f 62 6a 65 63 74 49 6e 76 6f 63  emoteObjectInvoc</span><br><span class="line">00f0   61 74 69 6f 6e 48 61 6e 64 6c 65 72 00 00 00 00  ationHandler....</span><br><span class="line">0100   00 00 00 02 02 00 00 70 78 72 00 1c 6a 61 76 61  .......pxr..java</span><br><span class="line">0110   2e 72 6d 69 2e 73 65 72 76 65 72 2e 52 65 6d 6f  .rmi.server.Remo</span><br><span class="line">0120   74 65 4f 62 6a 65 63 74 d3 61 b4 91 0c 61 33 1e  teObject.a...a3.</span><br><span class="line">0130   03 00 00 70 78 70 77 37 00 0a 55 6e 69 63 61 73  ...pxpw7..Unicas</span><br><span class="line">0140   74 52 65 66 00 0e 31 39 32 2e 31 36 38 2e 34 33  tRef..192.168.43</span><br><span class="line">0150   2e 31 36 32 00 00 ec 3c ba 3f a1 47 ea 85 db bb  .162...&lt;.?.G....</span><br><span class="line">0160   82 3c 5d f8 00 00 01 7e 4c 4d 6c e9 80 01 01 78  .&lt;]....~LMl....x</span><br></pre></td></tr></table></div></figure>

<p>这里传输的是服务器的序列化数据。注意以上加粗倾斜的部分。<strong>\xAC\xED</strong>是<code>Java序列化</code>的魔术头，该数据流往后的部分就是序列化的内容了。<strong>\xEC\x3C</strong>转换成十进制为<code>60476</code>，这便是<code>Server</code>在本地开放的随机端口。</p>
<p>我们分析一下<code>第一条TCP链接</code>干了什么。首先<code>Client</code>根据传入的<strong>rmi地址链接远端服务器1099端口上的RMI Registry</strong>，然后<code>Registry</code>向<code>Client</code>发送<code>Server上的序列化数据</code>，包括IP和开放的随机端口等。</p>

        <h2 id="第二条TCP链接">
          <a href="#第二条TCP链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二条TCP链接" class="headerlink" title="第二条TCP链接"></a>第二条TCP链接</h2>
      <p>再往下是<code>第二个TCP链接</code>，<code>Client</code>连接<code>ReturnData中返回的端口</code>，这条<strong>TCP链接用于Client与Server之间的传输数据</strong>。实际上是<code>Client的Stub和Server上的Skeleton之间</code>进行数据传输的。</p>
<p><img src="/2024/01/31/JavaSec-RMI/11.png"></p>
<p><img src="/2024/01/31/JavaSec-RMI/12.png"></p>

        <h2 id="两条TCP链接分别断开">
          <a href="#两条TCP链接分别断开" class="heading-link"><i class="fas fa-link"></i></a><a href="#两条TCP链接分别断开" class="headerlink" title="两条TCP链接分别断开"></a>两条TCP链接分别断开</h2>
      <p>再往后就是四次挥手，两条TCP链接分别断开</p>
<p><img src="/2024/01/31/JavaSec-RMI/13.png"></p>
<p>RMI Registry就像一个网关，Server在Registry中注册绑定在name上的远程对象，Client在Registry中根据name查询远程对象绑定信息。然后Client的Stub连接位于Server上的Skeleton，最终远程方法还是在服务器上执行。</p>
<p><img src="/2024/01/31/JavaSec-RMI/14.png"></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ FIN ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Autor: </span><span class="copyright-author__value"><a href="https://hyggevv.github.io">hey</a></span></div><div class="copyright-link"><span class="copyright-link__name">Enlace: </span><span class="copyright-link__value"><a href="https://hyggevv.github.io/2024/01/31/JavaSec-RMI/">https://hyggevv.github.io/2024/01/31/JavaSec-RMI/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">Todos los artículos de este blog están bajo licencia  de <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> a menos que se indique lo contrario</span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2024/02/16/JavaSec-%E4%BB%8EIDEA%E6%96%AD%E7%82%B9%E5%88%86%E6%9E%90RMI%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">JavaSec-从IDEA断点分析RMI通信原理</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2024/01/28/2024realworldctf/"><span class="paginator-prev__text">Real World CTF Online Jeopardy</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Contenido</span><span class="sidebar-nav-ov">Reseña</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2"><span class="toc-number">1.</span> <span class="toc-text">
          学习大纲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ERMI"><span class="toc-number">2.</span> <span class="toc-text">
          关于RMI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">
          RMI概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">
          RMI的三层架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stubs-and-Skeletons"><span class="toc-number">2.3.</span> <span class="toc-text">
          Stubs and Skeletons</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">
          RMI的运行机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Remote-Method-Invocation"><span class="toc-number">3.</span> <span class="toc-text">
          Remote Method Invocation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">
          远程对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFUnicastRemoteObject%E7%9A%84%E6%97%B6%E5%80%99%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">
          继承UnicastRemoteObject的时候构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tips"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">
          tips</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E7%BB%A7%E6%89%BFUnicastRemoteObject%E7%9A%84%E6%97%B6%E5%80%99%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">
          没有继承UnicastRemoteObject的时候构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IHello-java"><span class="toc-number">3.1.3.</span> <span class="toc-text">
          IHello.java</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tips-1"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">
          tips</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">
          对象调用过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">
          本地对象的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">
          远程对象的调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI-Registry"><span class="toc-number">3.3.</span> <span class="toc-text">
          RMI Registry</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RMI-Registry%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="toc-number">3.3.1.</span> <span class="toc-text">
          RMI Registry的注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RMI-Registry%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">
          RMI Registry的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RMI%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">
          RMI的简单实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Server"><span class="toc-number">4.1.</span> <span class="toc-text">
          Server</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">
          接口实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%94%A8%E4%BA%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">
          创建类用于远程调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">
          实现调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-rmi-Naming"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">
          java.rmi.Naming</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">
          注册</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">4.1.4.</span> <span class="toc-text">
          服务器端完整代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IHello-java-1"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">
          IHello.java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RMIServer-java"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">
          RMIServer.java</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Client"><span class="toc-number">4.2.</span> <span class="toc-text">
          Client</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">4.2.1.</span> <span class="toc-text">
          客户端完整代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IHello-java-2"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">
          IHello.java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RMIClient-java"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">
          RMIClient.java</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JRMP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">
          JRMP协议分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%9D%A1TCP%E9%93%BE%E6%8E%A5"><span class="toc-number">5.1.</span> <span class="toc-text">
          第一条TCP链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%9D%A1TCP%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.</span> <span class="toc-text">
          第二条TCP链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%9D%A1TCP%E9%93%BE%E6%8E%A5%E5%88%86%E5%88%AB%E6%96%AD%E5%BC%80"><span class="toc-number">5.3.</span> <span class="toc-text">
          两条TCP链接分别断开</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/usually.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">hey</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">102</div><div class="sidebar-ov-state-item__name">Archivo</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Categorías</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">Etiquetas</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">Has leído </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2024</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>hey</span></div><div><span>Potenciado por <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v5.4.2</span><span class="footer__devider">|</span><span>Tema - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.7.0</span></div><div class="busuanzi"><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">Vistas</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.7.0"></script><script src="/js/stun-boot.js?v=2.7.0"></script><script src="/js/scroll.js?v=2.7.0"></script><script src="/js/header.js?v=2.7.0"></script><script src="/js/sidebar.js?v=2.7.0"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":180,"height":300},"mobile":{"show":true},"log":false});</script></body></html>